import net
import hpack

class Frame:
    def serialize(self):
        return b''

PADDED = 0x8
END_STREAM = 0x1

class DataFrame(Frame):

    def __init__(self, data: bytes, pad_len: int, stream_id: u32, end_stream=False):
        self.data = data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.end_stream = end_stream

    def serialize(self):
        serialized = b''

        length = len(self.data)
        flags = 0x0
        if self.pad_len > 0:
            length += self.pad_len + 8
            flags |= PADDED

        if self.end_stream:
            flags |= END_STREAM

        serialized += bytes([length & 0xFF0000, length & 0xFF00, length & 0xFF])
        # Type field
        serialized += bytes([0x00])
        serialized += bytes([flags])
        serialized += bytes([int(self.stream_id & 0x7F000000), int(self.stream_id & 0xFF0000), int(self.stream_id & 0xFF00), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        serialized += self.data
        serialized += b'\x00' * self.pad_len

        return serialized

PRIORITY = 0x20
END_HEADERS = 0x04

class HeadersFrame(Frame):
    def __init__(self, field_data: bytes, pad_len: int, stream_id: u32, priority: bool, end_headers: bool, end_stream: bool):
        self.field_data = field_data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.priority = priority
        self.end_headers = end_headers
        self.end_stream = end_stream

    def serialize(self) -> bytes:
        serialized = b''

        length = len(self.field_data)

        flags = 0x0
        if self.pad_len > 0:
            length += self.pad_len + 8
            flags |= PADDED

        if self.priority:
            length += 5
            flags |= PRIORITY
        if self.end_headers:
            flags |= END_HEADERS
        if self.end_stream:
            flags |= END_STREAM

        # Type field
        serialized += bytes([0x01])
        serialized += bytes([flags])
        serialized += bytes([int(self.stream_id & 0x7F000000), int(self.stream_id & 0xFF0000), int(self.stream_id & 0xFF00), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        serialized += b'\x00' * self.pad_len

        return serialized

class PriorityFrame(Frame):
    pass

class RstStreamFrame(Frame):
    pass

class SettingFrame(Frame):
    pass

class PushPromiseFrame(Frame):
    pass

class PingFrame(Frame):
    pass

class GoAwayFrame(Frame):
    pass

class WindowUpdateFrame(Frame):
    pass

class ContinuationFrame(Frame):
    pass

class Stream:
    stream_id: u32
    #on_receive: action(Http2Client, int, bytes) -> None
    recv_buffer: bytes

    def __init__(self, stream_id: u32, on_receive: action(Http2Client, int, bytes) -> None):
        self.stream_id = stream_id
        self.on_receive = on_receive
        self.recv_buffer = b''

    def receive_frame(self, frame: Frame):
        pass

actor Http2Client(cap: net.TCPConnectCap, address: str, port: int, on_connect: action(Http2Client) -> None, on_error: action(Http2Client, str) -> None, tls_verify: bool=True, connect_timeout: float=10.0):

    var recv_buffer = b''
    var send_queue: list[Frame] = []
    var next_stream_id: u32 = 1
    var streams = {}
    var inflater = hpack.Inflater()
    var deflater = hpack.Deflater()

    var tcp_conn: ?net.TCPConnection = None

    def _connect():
        #tls_port = port if port is not None else 443
        tcp_port = port if port is not None else 80

        #tls_conn = net.TLSConnection(cap, address, tls_port, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, tls_verify)
        tcp_conn = net.TCPConnection(cap, address, tcp_port, _on_tcp_connect, _on_tcp_receive, _on_tcp_error, _on_tcp_remote_close)

    def _on_tls_connect(con: net.TLSConnection) -> None:
        #on_connect(self)
        pass

    def _on_tls_receive(con: net.TLSConnection, data: bytes) -> None:
        #on_receive(self, data)
        pass

    def _on_tls_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_tcp_remote_close(con: net.TCPListenConnection) -> None:
        #on_remote_close(self)
        pass

    def _on_tcp_connect(con: net.TCPConnection) -> None:
        #on_connect(self)
        pass

    def _on_tcp_receive(con: net.TCPConnection, data: bytes) -> None:
        print(data)
        pass

    def _on_tcp_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_remote_close(con: net.TLSConnection) -> None:
        #on_remote_close(self)
        pass

    def _send_frames():
        for frame in send_queue:
            if tcp_conn is not None:
                tcp_conn.write(frame.serialize())

    def get(path: str, on_receive: action(Http2Client, int, bytes) -> None):
        new_stream: Stream = Stream(next_stream_id, on_receive)
        #streams[next_stream_id] = new_stream
        next_stream_id += 2
        headers = { ':method': 'GET',
                    ':scheme': 'https',
                    ':authority': address,
                    ':path': path }

        header_data = deflater.deflate(headers)
        header_frame = HeadersFrame(header_data, 0, new_stream.stream_id, False, True, False)

        send_queue.append(header_frame)
        _send_frames()

        #on_receive(self, 418, b'I am a teapot')

    _connect()

def _test_get(env: Env):
    pass

def exit(env: Env):
    env.exit(0)

actor main(env):
    #_test_get(env)
    def _on_connect(client: Http2Client):
        pass

    def _on_error(client: Http2Client, message: str):
        print(message)

    def _on_receive(client: Http2Client, http_code: int, payload: bytes):
        print(payload)
        env.exit(0)

    #139.162.123.134
    test_client = Http2Client(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 443, _on_connect, _on_error)

    #tls_conn = net.TLSConnection(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 443, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, True)
    #after 10: exit(env)
    test_client.get('/', _on_receive)
