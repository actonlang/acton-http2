import net
import hpack

CLIENT_PREFACE: bytes = b'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n'


class Frame:
    def serialize(self):
        return b''

PADDED: u32 = 0x8
END_STREAM: u32 = 0x1

class DataFrame(Frame):

    def __init__(self, data: bytes, pad_len: int, stream_id: u32, end_stream=False):
        self.data = data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.end_stream = end_stream

    def serialize(self):
        serialized = b''

        length = u32(len(self.data))
        flags: u32 = 0x0
        if self.pad_len > 0:
            length += u32(self.pad_len + 8)
            flags |= PADDED

        if self.end_stream:
            flags |= END_STREAM

        serialized += bytes([int(length & 0xFF0000), int(length & 0xFF00), int(length & 0xFF)])
        # Type field
        serialized += bytes([0x00])
        serialized += bytes([int(flags)])
        serialized += bytes([int(self.stream_id & 0x7F000000), int(self.stream_id & 0xFF0000), int(self.stream_id & 0xFF00), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        serialized += self.data
        serialized += b'\x00' * self.pad_len

        return serialized

PRIORITY: u32 = 0x20
END_HEADERS: u32 = 0x04

class HeadersFrame(Frame):
    def __init__(self, field_data: bytes, pad_len: int, stream_id: u32, priority: bool, end_headers: bool, end_stream: bool):
        self.field_data = field_data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.priority = priority
        self.end_headers = end_headers
        self.end_stream = end_stream

    def serialize(self) -> bytes:
        serialized = b''

        length = len(self.field_data)

        flags:u32 = 0x0
        if self.pad_len > 0:
            length += self.pad_len + 8
            flags |= PADDED

        if self.priority:
            length += 5
            flags |= PRIORITY
        if self.end_headers:
            flags |= END_HEADERS
        if self.end_stream:
            flags |= END_STREAM

        length32: u32 = u32(length)

        serialized += bytes([int((length32 & 0xFF0000) >> 16), int((length32 & 0xFF00) >> 8), int(length32 & 0xFF)])
        # Type field
        serialized += bytes([0x01])
        serialized += bytes([int(flags)])
        serialized += bytes([int((self.stream_id & 0x7F000000) >> 24), int((self.stream_id & 0xFF0000) >> 16), int((self.stream_id & 0xFF00) >> 8), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        if self.priority:
            # Stub for implementing priority later
            pass
        serialized += self.field_data
        serialized += b'\x00' * self.pad_len

        return serialized

class PriorityFrame(Frame):
    pass

class RstStreamFrame(Frame):
    pass

class SettingsFrame(Frame):
    def __init__(self, settings: dict[u16, u32], ack: bool = False):
        self.settings = settings

        #if ack and len(self.settings > 0):
        #    raise ValueError("ACK flag cannot coincide with payload in SETTINGS frame")

        self.ack = ack

    def serialize(self) -> bytes:
        serialized = b''

        #length: int = len(self.settings.items()) * 6
        length = 0

        flags: int = 0x01 if self.ack else 0x00

        length32: u32 = u32(length)

        serialized += bytes([int((length32 & 0xFF0000) >> 16), int((length32 & 0xFF00) >> 8), int(length32 & 0xFF)])
        # Type field
        serialized += bytes([0x05])
        serialized += bytes([flags])
        # Stream ID always 0 for settings frame
        serialized += bytes([0x00, 0x00, 0x00, 0x00])
        #for name, value in self.settings.items():
        #    #stub settings payload for now
        #    pass

        return serialized

class PushPromiseFrame(Frame):
    pass

class PingFrame(Frame):
    pass

class GoAwayFrame(Frame):
    pass

class WindowUpdateFrame(Frame):
    pass

class ContinuationFrame(Frame):
    pass

class Stream:
    stream_id: u32
    #on_receive: action(Http2Client, int, bytes) -> None
    recv_buffer: bytes

    def __init__(self, stream_id: u32, on_receive: action(Http2Client, int, bytes) -> None):
        self.stream_id = stream_id
        self.on_receive = on_receive
        self.recv_buffer = b''

    def receive_frame(self, frame: Frame):
        pass

actor Http2Client(cap: net.TCPConnectCap, address: str, port: int, on_connect: action(Http2Client) -> None, on_error: action(Http2Client, str) -> None, tls_verify: bool=True, connect_timeout: float=10.0):

    var recv_buffer = b''
    var send_queue: list[Frame] = []
    var next_stream_id: u32 = 1
    var streams = {}
    var inflater = hpack.Inflater()
    var deflater = hpack.Deflater()

    var tcp_conn: ?net.TCPConnection = None

    def _connect():
        #tls_port = port if port is not None else 443
        tcp_port = port if port is not None else 80

        #tls_conn = net.TLSConnection(cap, address, tls_port, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, tls_verify)
        tcp_conn = net.TCPConnection(cap, address, tcp_port, _on_tcp_connect, _on_tcp_receive, _on_tcp_error, _on_tcp_remote_close)

    def _on_tls_connect(con: net.TLSConnection) -> None:
        #on_connect(self)
        pass

    def _on_tls_receive(con: net.TLSConnection, data: bytes) -> None:
        #on_receive(self, data)
        pass

    def _on_tls_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_tcp_remote_close(con: net.TCPListenConnection) -> None:
        #on_remote_close(self)
        pass

    def _on_tcp_connect(con: net.TCPConnection) -> None:
        #on_connect(self)
        con.write(CLIENT_PREFACE)
        con.write(SettingsFrame({}).serialize())
        pass

    def _on_tcp_receive(con: net.TCPConnection, data: bytes) -> None:
        print(data)
        pass

    def _on_tcp_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_remote_close(con: net.TLSConnection) -> None:
        #on_remote_close(self)
        pass

    def _send_frames():
        for frame in send_queue:
            if tcp_conn is not None:
                send_bytes = frame.serialize()
                print("Sending TCP data: ", send_bytes)
                #tcp_conn.write(send_bytes)

    def get(path: str, on_receive: action(Http2Client, int, bytes) -> None):
        print("next_stream_id: ", next_stream_id)
        new_stream: Stream = Stream(u32(next_stream_id), on_receive)
        print("new_stream.stream_id: ", new_stream.stream_id)
        streams[u32(next_stream_id)] = new_stream
        next_stream_id += 2
        print("new_stream.stream_id: ", new_stream.stream_id)
        headers = { ':method': 'GET',
                    ':scheme': 'https',
                    ':authority': address,
                    ':path': path }

        header_data = deflater.deflate(headers)
        print("New stream id: ", new_stream.stream_id)
        print("Compressed header data: ", header_data)
        header_frame = HeadersFrame(header_data, 0, new_stream.stream_id, False, True, False)

        send_queue.append(header_frame)
        _send_frames()

        #on_receive(self, 418, b'I am a teapot')

    _connect()

def _test_get(env: Env):
    pass

def exit(env: Env):
    env.exit(0)

actor main(env):

    #_test_get(env)
    def _on_connect(client: Http2Client):
        pass

    def _on_error(client: Http2Client, message: str):
        print(message)

    def _on_receive(client: Http2Client, http_code: int, payload: bytes):
        print(payload)
        env.exit(0)

    #139.162.123.134
    test_client = Http2Client(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 80, _on_connect, _on_error)

    #tls_conn = net.TLSConnection(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 443, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, True)
    #after 10: exit(env)
    test_client.get('/', _on_receive)
