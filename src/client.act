import net
import hpack

CLIENT_PREFACE: bytes = b'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n'


class Frame:
    def __init__(self):
        self.stream_id = 0

    def __str__(self):
        return 'Frame()'

    def serialize(self):
        return b''

PADDED: u32 = 0x8
END_STREAM: u32 = 0x1

class DataFrame(Frame):

    def __init__(self, data: bytes, pad_len: int, stream_id: u32, end_stream=False):
        self.data = data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.end_stream = end_stream

    def __str__(self):
        data_excerpt = self.data if len(self.data) < 20 else self.data[:20]
        return 'DataFrame(data=' + str(data_excerpt) + ', pad_len=' + str(self.pad_len) + ', stream_id=' + str(self.stream_id) + ', end_stream=' + str(self.end_stream) + ')'

    def serialize(self):
        serialized = b''

        length = u32(len(self.data))
        flags: u32 = 0x0
        if self.pad_len > 0:
            length += u32(self.pad_len + 1)
            flags |= PADDED

        if self.end_stream:
            flags |= END_STREAM

        serialized += bytes([int(length & 0xFF0000), int(length & 0xFF00), int(length & 0xFF)])
        # Type field
        serialized += bytes([0x00])
        serialized += bytes([int(flags)])
        serialized += bytes([int(self.stream_id & 0x7F000000), int(self.stream_id & 0xFF0000), int(self.stream_id & 0xFF00), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        serialized += self.data
        serialized += b'\x00' * self.pad_len

        return serialized

PRIORITY: u32 = 0x20
END_HEADERS: u32 = 0x04

class HeadersFrame(Frame):
    def __init__(self, field_data: bytes, pad_len: int, stream_id: u32, priority: bool, end_headers: bool, end_stream: bool):
        self.field_data = field_data
        self.pad_len = pad_len
        self.stream_id = stream_id
        self.priority = priority
        self.end_headers = end_headers
        self.end_stream = end_stream

    def __str__(self):
        data_excerpt = self.field_data if len(self.field_data) < 20 else self.field_data[:20]
        return 'HeadersFrame(field_data=' + str(data_excerpt) + ', pad_len=' + str(self.pad_len) + ', stream_id=' + str(self.stream_id) + ', priority=' + str(self.priority) +', end_headers=' + str(self.end_headers) +', end_stream=' + str(self.end_stream) + ')'

    def serialize(self) -> bytes:
        serialized = b''

        length = len(self.field_data)

        flags:u32 = 0x0
        if self.pad_len > 0:
            length += self.pad_len + 1
            flags |= PADDED

        if self.priority:
            length += 5
            flags |= PRIORITY
        if self.end_headers:
            flags |= END_HEADERS
        if self.end_stream:
            flags |= END_STREAM

        length32: u32 = u32(length)

        serialized += bytes([int((length32 & 0xFF0000) >> 16), int((length32 & 0xFF00) >> 8), int(length32 & 0xFF)])
        # Type field
        serialized += bytes([0x01])
        serialized += bytes([int(flags)])
        serialized += bytes([int((self.stream_id & 0x7F000000) >> 24), int((self.stream_id & 0xFF0000) >> 16), int((self.stream_id & 0xFF00) >> 8), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        if self.priority:
            # Stub for implementing priority later
            pass
        serialized += self.field_data
        serialized += b'\x00' * self.pad_len

        return serialized

class PriorityFrame(Frame):
    pass

class RstStreamFrame(Frame):
    def __init__(self, error_code: int, stream_id: u32):
        self.error_code = error_code
        self.stream_id = stream_id

    def __str__(self) -> str:
        return 'RstStreamFrame(error_code=' + str(self.error_code) + ', stream_id=' + str(self.stream_id) + ')'

    def serialize(self) -> bytes:
        serialized = b''
        serialized += bytes([0x00, 0x00, 0x04])
        # Type field
        serialized += bytes([0x03])
        serialized += bytes([0x00])
        serialized += bytes([int((self.stream_id & 0x7F000000) >> 24), int((self.stream_id & 0xFF0000) >> 16), int((self.stream_id & 0xFF00) >> 8), int(self.stream_id & 0xFF)])
        error_code32 = u32(self.error_code)
        serialized += bytes([int((error_code32 & 0xFF000000) >> 24), int((error_code32 & 0xFF0000) >> 16), int((error_code32 & 0xFF00) >> 8), int(error_code32 & 0xFF)])

        return serialized
        

class SettingsFrame(Frame):
    def __init__(self, settings: dict[u16, u32], ack: bool = False):
        self.settings = settings

        #if ack and len(self.settings > 0):
        #    raise ValueError("ACK flag cannot coincide with payload in SETTINGS frame")

        self.ack = ack

    def __str__(self) -> str:
        return 'SettingsFrame(settings=' + str(self.settings) + ', ack=' + str(self.ack) + ')'

    def serialize(self) -> bytes:
        serialized = b''

        #length: int = len(self.settings.items()) * 6
        length = 0

        flags: int = 0x01 if self.ack else 0x00

        length32: u32 = u32(length)

        serialized += bytes([int((length32 & 0xFF0000) >> 16), int((length32 & 0xFF00) >> 8), int(length32 & 0xFF)])
        # Type field
        serialized += bytes([0x04])
        serialized += bytes([flags])
        # Stream ID always 0 for settings frame
        serialized += bytes([0x00, 0x00, 0x00, 0x00])
        #for name, value in self.settings.items():
        #    #stub settings payload for now
        #    pass

        return serialized

class PushPromiseFrame(Frame):
    def __init__(self, promised_stream_id: u32, field_data: bytes, pad_len: int, stream_id: u32, end_headers: bool):
        self.field_data = field_data
        self.pad_len = pad_len
        self.promised_stream_id = promised_stream_id
        self.stream_id = stream_id
        self.end_headers = end_headers

    def __str__(self):
        data_excerpt = self.field_data if len(self.field_data) < 20 else self.field_data[:20]
        return 'PushPromiseFrame(field_data=' + str(data_excerpt) + ', pad_len=' + str(self.pad_len) + ', promised_stream_id=' + str(self.promised_stream_id) + ', stream_id=' + str(self.stream_id) + ', end_headers=' + str(self.end_headers) + ')'

    def serialize(self) -> bytes:
        serialized = b''

        length = len(self.field_data) + 4

        flags:u32 = 0x0
        if self.pad_len > 0:
            length += self.pad_len + 1
            flags |= PADDED

        if self.end_headers:
            flags |= END_HEADERS

        length32: u32 = u32(length)

        serialized += bytes([int((length32 & 0xFF0000) >> 16), int((length32 & 0xFF00) >> 8), int(length32 & 0xFF)])
        # Type field
        serialized += bytes([0x01])
        serialized += bytes([int(flags)])
        serialized += bytes([int((self.stream_id & 0x7F000000) >> 24), int((self.stream_id & 0xFF0000) >> 16), int((self.stream_id & 0xFF00) >> 8), int(self.stream_id & 0xFF)])
        if self.pad_len > 0:
            serialized += bytes([self.pad_len & 0xFF])
        serialized += bytes([int((self.promised_stream_id & 0x7F000000) >> 24), int((self.promised_stream_id & 0xFF0000) >> 16), int((self.promised_stream_id & 0xFF00) >> 8), int(self.promised_stream_id & 0xFF)])
        serialized += self.field_data
        serialized += b'\x00' * self.pad_len

        return serialized

class PingFrame(Frame):
    pass

class GoAwayFrame(Frame):
    def __init__(self, last_stream_id: u32, error_code: int, debug_data: bytes):
        self.last_stream_id = last_stream_id
        self.error_code = error_code
        self.debug_data = debug_data

    def __str__(self) -> str:
        return 'GoAwayFrame(last_stream_id=' + str(self.last_stream_id) + ', error_code=' + str(self.error_code) + ', debug_data=' + str(self.debug_data) + ')'

class WindowUpdateFrame(Frame):
    def __init__(self, increment_size: u32, stream_id: u32):
        self.increment_size = increment_size
        self.stream_id = stream_id

    def serialize(self) -> bytes:
        serialized = b''

        # Length 0x4
        serialized += bytes([0x00, 0x00, 0x04])
        # Frame type
        serialized += bytes([0x08])

        # Blank flags
        serialized += bytes([0x00])

        serialized += bytes([int((self.stream_id & 0x7F000000) >> 24), int((self.stream_id & 0xFF0000) >> 16), int((self.stream_id & 0xFF00) >> 8), int(self.stream_id & 0xFF)])

        serialized += bytes([int((self.increment_size & 0x7F000000) >> 24), int((self.increment_size & 0xFF0000) >> 16), int((self.increment_size & 0xFF00) >> 8), int(self.increment_size & 0xFF)])

        return serialized
        

class ContinuationFrame(Frame):
    pass

class Response(object):
    headers: dict[str, str]
    data: bytes
    outstanding_streams: dict[u32, u32]

    def __init__(self, request_headers: dict[str, str], on_receive: action(Http2Client, dict[str, str], bytes) -> None):
        self.request_headers = request_headers
        self.headers = {}
        self.data = b''
        self.on_receive = on_receive
        self.outstanding_streams = {}

    def stream_response(self, stream_id: u32, headers: dict[str, str], data: bytes) -> bool:
        for header_name, header_val in headers.items():
            self.headers[header_name] = header_val

        self.data += data

        self.outstanding_streams[stream_id] = False

        for waiting in self.outstanding_streams.values():
            if waiting:
                return False

        return True

class Stream(object):
    stream_id: u32
    #on_receive: action(Http2Client, int, bytes) -> None
    client: Http2Client
    fields_buffer: bytes
    pp_fields_buffer: bytes
    data_buffer: bytes

    def __init__(self, stream_id: u32):
        self.stream_id = stream_id
        self.fields_buffer = b''
        self.pp_fields_buffer = b''
        self.data_buffer = b''

    def receive_frame(self, frame: Frame) -> (list[Frame], bool, u32):
        if isinstance(frame, PushPromiseFrame):
            self.pp_fields_buffer += frame.field_data
            return ([WindowUpdateFrame(0x7fffffff, frame.promised_stream_id)], False, frame.promised_stream_id)
        elif isinstance(frame, DataFrame):
            self.data_buffer += frame.data
            return [WindowUpdateFrame(0x7fffffff, self.stream_id)], frame.end_stream, 0
        elif isinstance(frame, HeadersFrame):
            self.fields_buffer += frame.field_data
            return [], frame.end_stream, 0
        else:
            return ([], False, 0)

def decode_frame(buffer: bytes) -> (?Frame, int):
    length = (buffer[0] << 16) + (buffer[1] << 8) + buffer[2]
    type = buffer[3]
    flags = u32(buffer[4])
    stream_id = u32((buffer[5] << 24) + (buffer[6] << 16) +
                    (buffer[7] << 8) + buffer[8]) & 0x7fffffff

    buffer = buffer[9:]
    remaining_length = len(buffer)
    #print('Decoding frame of type ', type, ' for stream ', stream_id, ' with length ', length)
    if remaining_length < length:
        print('Incomplete frame data in buffer (', remaining_length, '/', length, ' bytes received)')
        return None, 0

    if type == 0:
        # DATA
        pad_len = 0
        end_stream = bool(flags & END_STREAM)
        if flags & PADDED:
            pad_len = buffer[0]
            buffer = buffer[1:]
        data = buffer[:length-pad_len]
        return DataFrame(data, pad_len, stream_id, end_stream), (length + 9)
    elif type == 1:
        # HEADERS
        pad_len = 0
        field_data_len = length
        priority = bool(flags & PRIORITY)
        end_headers = bool(flags & END_HEADERS)
        end_stream = bool(flags & END_STREAM)
        if flags & PADDED:
            pad_len = buffer[0]
            buffer = buffer[1:]
            field_data_len -= (1 + pad_len)
        if priority:
            stream_dependency = u32((buffer[0] << 24) + (buffer[1] << 16) +
                                    (buffer[2] << 2) + buffer[3]) & 0x7fffffff
            weight = buffer[4]
            buffer = buffer[5:]
            field_data_len -= 5
        return HeadersFrame(buffer[:field_data_len], pad_len, stream_id, priority, end_headers, end_stream), (length + 9)
    elif type == 3:
        error_code = ((buffer[0] << 24) + (buffer[1] << 16) +
                      (buffer[2] << 2) + buffer[3])
        return RstStreamFrame(error_code, stream_id), 13
    elif type == 4:
        # SETTINGS
        settings = {}
        for i in range(0, length, 6):
            setting_id = u16((buffer[0] << 8) + buffer[1])
            setting_value = u32((buffer[2] << 24) + (buffer[3] << 16) +
                             (buffer[4] << 8) + buffer[5])
            settings[setting_id] = setting_value
        print('SETTINGS frame decoded, ', (length + 9), ' bytes consumed from buffer')
        return SettingsFrame(settings, flags == 0x1), (length + 9)
    elif type == 5:
        pad_len = 0
        field_data_len = length - 4
        end_headers = bool(flags & END_HEADERS)
        if flags & PADDED:
            pad_len = buffer[0]
            buffer = buffer[1:]
            field_data_len -= 1
        promised_stream_id = u32((buffer[0] << 24) + (buffer[1] << 16) +
                                 (buffer[2] << 2) + buffer[3]) & 0x7fffffff
        buffer = buffer[4:]
        return PushPromiseFrame(promised_stream_id, buffer[:field_data_len], pad_len, stream_id, end_headers), (length + 9)
    elif type == 7:
        last_stream_id = u32((buffer[0] << 24) + (buffer[1] << 16) +
                             (buffer[2] << 2) + buffer[3]) & 0x7fffffff
        error_code = ((buffer[0] << 24) + (buffer[1] << 16) +
                         (buffer[2] << 2) + buffer[3])
        debug_data = buffer[4:length]
        return GoAwayFrame(last_stream_id, error_code, debug_data), (length + 9)
        
        
    print("Unknown frame type", type)
    return None, 0


actor Http2Client(cap: net.TCPConnectCap, address: str, port: int, on_connect: action(Http2Client) -> None, on_error: action(Http2Client, str) -> None, tls_verify: bool=True, connect_timeout: float=10.0):

    var recv_buffer = b''
    var send_queue: list[Frame] = []
    var next_stream_id: u32 = 1
    var streams: dict[u32, Stream] = {}
    var responses: dict[u32, Response] = {}
    var promised_pushes: list[(dict[str, str], Stream)] = []
    var inflater = hpack.Inflater()
    var deflater = hpack.Deflater()
    var ready: bool = False
    # safe constant for max size for now
    # should be configurable in settings
    var max_frame_size = 16384

    var tcp_conn: ?net.TCPConnection = None

    def _connect():
        #tls_port = port if port is not None else 443
        tcp_port = port if port is not None else 80

        #tls_conn = net.TLSConnection(cap, address, tls_port, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, tls_verify)
        tcp_conn = net.TCPConnection(cap, address, tcp_port, _on_tcp_connect, _on_tcp_receive, _on_tcp_error, _on_tcp_remote_close)

    def _on_tls_connect(con: net.TLSConnection) -> None:
        #on_connect(self)
        pass

    def _on_tls_receive(con: net.TLSConnection, data: bytes) -> None:
        #on_receive(self, data)
        pass

    def _on_tls_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_tcp_remote_close(con: net.TCPListenConnection) -> None:
        #on_remote_close(self)
        pass

    def _on_tcp_connect(con: net.TCPConnection) -> None:
        #on_connect(self)
        print("Sending TCP data: ", CLIENT_PREFACE)
        con.write(CLIENT_PREFACE)
        
        send_bytes: bytes = SettingsFrame({}).serialize()
        print("Sending TCP data: ", send_bytes)
        con.write(send_bytes)
        ready = True
        _send_frames()

    def _on_tcp_receive(con: net.TCPConnection, data: bytes) -> None:
        #print("Received TCP data:", data)
        recv_buffer += data
        #print('First 100 bytes of recv_buffer: ', recv_buffer[:100])
        frame, consumed_bytes = decode_frame(recv_buffer)
        
        if frame is not None:
            recv_buffer = recv_buffer[consumed_bytes:]
            if isinstance(frame, SettingsFrame):
                print('Received settings frame')
                for setting in frame.settings.items():
                    print('  setting ', setting)
                if not frame.ack:
                    send_queue.append(SettingsFrame({}, True))
            elif isinstance(frame, GoAwayFrame):
                print('Received GOAWAY frame with Last-Stream-ID', frame.last_stream_id,
                      ' and error code', frame.error_code)
            else:
                print('Received frame', frame)
                dest_stream = streams[frame.stream_id]
                dest_response = responses[frame.stream_id]
                reply_frames, end_stream, new_stream_id = dest_stream.receive_frame(frame)
                for frame in reply_frames:
                    send_queue.append(frame)
                if new_stream_id > 0:
                    print("Launch new stream with id", new_stream_id)
                    print("Stream", frame.stream_id, "headers:", inflater.inflate(dest_stream.pp_fields_buffer))
                    streams[new_stream_id] = Stream(new_stream_id)
                    #responses[new_stream_id] = dest_response
                if end_stream:
                    print("Stream", frame.stream_id, "ended")
                    print(" headers:", inflater.inflate(dest_stream.fields_buffer))
                    print(" data:", dest_stream.data_buffer)
                    if dest_response.stream_response(dest_stream.stream_id, inflater.inflate(dest_stream.fields_buffer), dest_stream.data_buffer):
                        dest_response.on_receive(self, dest_response.headers, dest_response.data)

        _send_frames()

    def _on_tcp_error(conn: net.TCPConnection, error: str) -> None:
        #on_error(self, error)
        pass

    def _on_remote_close(con: net.TLSConnection) -> None:
        #on_remote_close(self)
        pass

    def _send_frames():
        for frame in send_queue:
            if tcp_conn is not None:
                send_queue.pop()
                send_bytes = frame.serialize()
                print("Sending TCP data: ", send_bytes)
                tcp_conn.write(send_bytes)

    def get(path: str, on_receive: action(Http2Client, dict[str, str], bytes) -> None):
        print("next_stream_id: ", next_stream_id)
        new_stream: Stream = Stream(u32(next_stream_id))
        print("new_stream.stream_id: ", new_stream.stream_id)
        streams[new_stream.stream_id] = new_stream
        next_stream_id += 2
        print("new_stream.stream_id: ", new_stream.stream_id)
        headers = { ':method': 'GET',
                    ':scheme': 'http',
                    ':authority': address,
                    ':path': path }
        new_response: Response = Response(headers, on_receive)
        responses[new_stream.stream_id] = new_response

        header_data = deflater.deflate(headers)
        print("New stream id: ", new_stream.stream_id)
        print("Compressed header data: ", header_data)
        header_frame = HeadersFrame(header_data, 0, new_stream.stream_id, False, True, True)

        send_queue.append(header_frame)
        if ready:
            _send_frames()

        #on_receive(self, 418, b'I am a teapot')

    def post(path: str, body: bytes, on_receive: action(Http2Client, dict[str, str], bytes) -> None):
        print("next_stream_id: ", next_stream_id)
        new_stream: Stream = Stream(u32(next_stream_id))
        print("new_stream.stream_id: ", new_stream.stream_id)
        streams[new_stream.stream_id] = new_stream
        next_stream_id += 2
        print("new_stream.stream_id: ", new_stream.stream_id)
        headers = { ':method': 'POST',
                    ':scheme': 'http',
                    ':authority': address,
                    ':path': path }
        new_response: Response = Response(headers, on_receive)
        responses[new_stream.stream_id] = new_response

        header_data = deflater.deflate(headers)
        print("New stream id: ", new_stream.stream_id)
        print("Compressed header data: ", header_data)
        header_frame = HeadersFrame(header_data, 0, new_stream.stream_id, False, True, False)

        send_queue.append(header_frame)

        while len(body) > max_frame_size:
             send_queue.append(DataFrame(body[:max_frame_size], 0, new_stream.stream_id, False))
             body = body[max_frame_size:]

        send_queue.append(DataFrame(body, 0, new_stream.stream_id, True))

        if ready:
            _send_frames()

    _connect()

def _test_get(env: Env):
    pass

def exit(env: Env):
    env.exit(0)

actor main(env):

    #_test_get(env)
    def _on_connect(client: Http2Client):
        pass

    def _on_error(client: Http2Client, message: str):
        print(message)

    def _on_receive(client: Http2Client, http_headers: dict[str, str], payload: bytes):
        print(http_headers)
        print(payload)
        env.exit(0)

    #139.162.123.134
    test_client = Http2Client(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 80, _on_connect, _on_error)

    #tls_conn = net.TLSConnection(net.TCPConnectCap(net.TCPCap(net.NetCap(env.cap))), 'nghttp2.org', 443, _on_tls_connect, _on_tls_receive, _on_tls_error, _on_remote_close, True)
    #after 10: exit(env)
    test_client.get('/', _on_receive)
